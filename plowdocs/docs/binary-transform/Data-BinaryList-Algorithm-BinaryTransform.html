<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.BinaryList.Algorithm.BinaryTransform</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-BinaryList-Algorithm-BinaryTransform.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-BinaryList-Algorithm-BinaryTransform.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">binary-transform-0.1.0.0: Implementation of the binary transform.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.BinaryList.Algorithm.BinaryTransform</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Bijections</a></li><li><a href="#g:2">Binary Transform</a><ul><li><a href="#g:3">Left version</a></li><li><a href="#g:4">Right version</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Implementation of the binary transform, as detailed in
   <a href="https://github.com/plow-technologies/writings/tree/master/binary-transform">https://github.com/plow-technologies/writings/tree/master/binary-transform</a>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Bijection">Bijection</a> a b = <a href="#v:Bijection">Bijection</a> {<ul class="subs"><li><a href="#v:direct">direct</a> :: a -&gt; b</li><li><a href="#v:inverse">inverse</a> :: b -&gt; a</li></ul>}</li><li class="src short"><a href="#v:inverseBijection">inverseBijection</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> a b -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> b a</li><li class="src short"><a href="#v:functorBijection">functorBijection</a> :: <a href="http://hackage.haskell.org/package/base/docs/Control-Monad.html#t:Functor">Functor</a> f =&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> a b -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (f a) (f b)</li><li class="src short"><a href="#v:productBijection">productBijection</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> a b -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> c d -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, c) (b, d)</li><li class="src short"><a href="#v:leftBinaryTransform">leftBinaryTransform</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a)</li><li class="src short"><a href="#v:leftInverseBinaryTransformDec">leftInverseBinaryTransformDec</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a</li><li class="src short"><a href="#v:leftPartialInverse">leftPartialInverse</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a</li><li class="src short"><a href="#v:rightBinaryTransform">rightBinaryTransform</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a)</li><li class="src short"><a href="#v:rightInverseBinaryTransformDec">rightInverseBinaryTransformDec</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a</li><li class="src short"><a href="#v:rightPartialInverse">rightPartialInverse</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a</li></ul></div><div id="interface"><h1 id="g:1">Bijections</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Bijection" class="def">Bijection</a> a b <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#Bijection" class="link">Source</a></p><div class="doc"><p>A bijection from <code>a</code> to <code>b</code> is a function from <code>a</code> to <code>b</code> that is invertible.
   A function is invertible if and only if it's both injective and surjective.
   These are the definitions of the terms <em>injective</em> and <em>surjective</em>.</p><ul><li>A function <code>f :: a -&gt; b</code> is <em>injective</em> if <code>f(x) = f(y)</code> implies <code>x = y</code>
     for every <code>x, y :: a</code>.</li><li>A function <code>f :: a -&gt; b</code> is <em>surjective</em> if for every <code>y :: b</code> there is
     <code>x :: a</code> such that <code>f(x) = y</code>.</li></ul><p>To apply a bijection <code>f</code> to an argument <code>x</code> use <code>direct f x</code>. To apply its
   inverse just do <code>inverse f x</code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Bijection" class="def">Bijection</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:direct" class="def">direct</a> :: a -&gt; b</dt><dd class="doc"><p>Bijection.</p></dd><dt class="src"><a name="v:inverse" class="def">inverse</a> :: b -&gt; a</dt><dd class="doc"><p>Inverse of the bijection.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Bijection" class="caption collapser" onclick="toggleSection('i:Bijection')">Instances</p><div id="section.i:Bijection" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base/docs/Control-Category.html#t:Category">Category</a> * <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inverseBijection" class="def">inverseBijection</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> a b -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> b a <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#inverseBijection" class="link">Source</a></p><div class="doc"><p>The inverse of a bijection.</p></div></div><div class="top"><p class="src"><a name="v:functorBijection" class="def">functorBijection</a> :: <a href="http://hackage.haskell.org/package/base/docs/Control-Monad.html#t:Functor">Functor</a> f =&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> a b -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (f a) (f b) <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#functorBijection" class="link">Source</a></p><div class="doc"><p>Lift a <code><a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a></code> to work over an arbitrary <code><a href="http://hackage.haskell.org/package/base/docs/Control-Monad.html#t:Functor">Functor</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:productBijection" class="def">productBijection</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> a b -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> c d -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, c) (b, d) <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#productBijection" class="link">Source</a></p><div class="doc"><p>The product of two bijections. This is the equivalent to <code><a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-42--42--42-">***</a></code> for the <code><a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a></code> type.</p></div></div><h1 id="g:2">Binary Transform</h1><h2 id="g:3">Left version</h2><div class="top"><p class="src"><a name="v:leftBinaryTransform" class="def">leftBinaryTransform</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#leftBinaryTransform" class="link">Source</a></p><div class="doc"><p>The <em>left binary transform</em> lifts a permutation (i.e. a bijection from
   a set to itself) of a plane to a permutation of binary lists. The transformation
   condenses at the <em>left</em>.</p></div></div><div class="top"><p class="src"><a name="v:leftInverseBinaryTransformDec" class="def">leftInverseBinaryTransformDec</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#leftInverseBinaryTransformDec" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:leftPartialInverse" class="def">leftPartialInverse</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#leftPartialInverse" class="link">Source</a></p><div class="doc"><p>Apply the inverse of a permutation of binary lists to a sublist of a binary list.
   The <code><a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a></code> argument specifies the size of the sublist. More specifically,
   applying <code>leftPartialInverse f i</code> to a binary list <code>xs</code> of length <code>2^n</code>
   returns the result of applying <code>inverse f</code> to the first <code>max{1,2^(n-i)}</code> elements.</p></div></div><h2 id="g:4">Right version</h2><div class="top"><p class="src"><a name="v:rightBinaryTransform" class="def">rightBinaryTransform</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#rightBinaryTransform" class="link">Source</a></p><div class="doc"><p>The <em>right binary transform</em> lifts a permutation (i.e. a bijection from
   a set to itself) of a plane to a permutation of binary lists. The transformation
   condenses at the <em>right</em>.</p></div></div><div class="top"><p class="src"><a name="v:rightInverseBinaryTransformDec" class="def">rightInverseBinaryTransformDec</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (a, a) (a, a) -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList-Serialize.html#t:Decoded">Decoded</a> a <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#rightInverseBinaryTransformDec" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:rightPartialInverse" class="def">rightPartialInverse</a> :: <a href="Data-BinaryList-Algorithm-BinaryTransform.html#t:Bijection">Bijection</a> (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) (<a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a -&gt; <a href="http://hackage.haskell.org/package/binary-list/docs/Data-BinaryList.html#t:BinList">BinList</a> a <a href="src/Data-BinaryList-Algorithm-BinaryTransform.html#rightPartialInverse" class="link">Source</a></p><div class="doc"><p>Apply the inverse of a permutation of binary lists to a sublist of a binary list.
   The <code><a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a></code> argument specifies the size of the sublist. More specifically,
   applying <code>rightPartialInverse f i</code> to a binary list <code>xs</code> of length <code>2^n</code>
   returns the result of applying <code>inverse f</code> to the last <code>max{1,2^(n-i)}</code> elements.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.15.0</p></div></body></html>