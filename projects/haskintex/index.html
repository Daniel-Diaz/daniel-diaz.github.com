<!DOCTYPE HTML>
<html>
<head>
<title>hask-in-tex</title>
<link rel="stylesheet" href="https://rawgithub.com/Daniel-Diaz/hatex-guide/master/hatex.css">
</head>
<body>
<h1 class="title">Hask<i>in</i>TeX</h1>
<p class="centered"><i>A program to evaluate Haskell code within LaTeX</i></p>
<p class="centered">Daniel DÃ­az</p>
<h1>The <i>haskintex</i> program</h1>

<p>
The <i>haskintex</i> program is a tool that reads a LaTeX file and evaluates Haskell expressions contained
in some specific commands and environments. It allows you to define your own functions, use any GHC Haskell language
extension and, in brief, anything you can do within Haskell. You can freely add any Haskell code you need, and make
this code appear <i>optionally</i> in the LaTeX output. It is a tiny program, and therefore, easy to understand, use and
predict.
</p>

<h1>Installation</h1>

<p>
To install <i>haskintex</i> from <a href="http://hackage.haskell.org/package/haskintex">Hackage</a>,
use the <i>cabal</i> program:
</p>

<pre>
$> cabal update
$> cabal install haskintex
</pre>

<p>
This will update your package database and install the latest version of <i>haskintex</i>.
Otherwise, you can build the current developing version downloading
<a href="https://github.com/Daniel-Diaz/haskintex/archive/master.zip">its code as a zip file</a>.
</p>

<h1>How does it work?</h1>

<p>
Consider the following simple example.
</p>

<pre>
\documentclass{article}
\begin{document}
I have \evalhaskell{2+3} fingers in my right hand.
\end{document}
</pre>

<p>
If the above LaTeX code is written in <code>foo.tex</code>, after running <code>haskintex foo.tex</code>
the file <code>haskintex_foo.tex</code> will be written with:
</p>

<pre>
\documentclass{article}
\begin{document}
I have \verb`5` fingers in my right hand.
\end{document}
</pre>

<p>
The Haskell code <code>2+3</code> has been evaluated to <code>5</code>, and the result has been enclosed
in a <code>verb</code> command. The evaluation is done using
<a href="http://www.haskell.org/ghc">GHC</a>, so it must be installed in order to use <code>haskintex</code>.
</p>

<p>
The file <code>foo.tex</code> can be processes running <code>hakintex foo</code> as well. When the given
input file does not exist, <i>haskintex</i> adds the <code>.tex</code> extension automatically.
If the file with the added extension does not exist, it throws an error.
</p>

<p>
Let's go through another example. The factorial function can be implemented recursively in Haskell.
</p>

<pre>
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
</pre>

To include this function in the scope of <code>evalhaskell</code> use <code>writehaskell</code> as
shown below.

<pre>
\documentclass{article}
\begin{document}
\begin{writehaskell}
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
\end{writehaskell}
While 5 factorial is \evalhaskell{fact 5}, 10 factorial is
\evalhaskell{fact 10}.
\end{document}
</pre>

<p>
Therefore, to add binding definitions use the <code>writehaskell</code> environment,
and to evaluate code use <code>evalhaskell</code>. If the output of an evaluation is
known to be big and it is not desired to be inlined, use <code>evalhaskell</code> as an environment
instead. For example:
</p>

<pre>
\documentclass{article}
\begin{document}
This is the list of numbers from 1 to 1000:
\begin{evalhaskell}
[1..1000]
\end{evalhaskell}
\end{document}
</pre>

<p>
Lines in the output of <code>evalhaskell</code> as <i>environment</i> are bounded to 60
characters. A line break will be introduced if this number is exceeded.
</p>

<h1>Code ordering</h1>

<p>
The place where <code>evalhaskell</code> is called does not really matter.
The function <code>fact</code> can be called <i>before</i> defining it.
</p>

<pre>
\documentclass{article}
\begin{document}
While 5 factorial is \evalhaskell{fact 5}, 10 factorial is
\evalhaskell{fact 10}.
\begin{writehaskell}
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
\end{writehaskell}
\end{document}
</pre>

What <i>haskintex</i> does is to traverse the LaTeX code twice. The first time it creates a module
with all the code defined with <code>writehaskell</code> environments. In the second pass, it evaluates
all the <code>evalhaskell</code> calls with the created module imported. Note that this means you have to avoid
duplicated names.

<h1>Visibility</h1>

<p>
By default, the Haskell code introduced by <code>writehaskell</code> will not show up in
the processed LaTeX code. To change this, use the <code>visible</code> option.
For example:
</p>

<pre>
\documentclass{article}
\begin{document}
\begin{writehaskell}[visible]
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
\end{writehaskell}
While 5 factorial is \evalhaskell{fact 5}, 10 factorial is
\evalhaskell{fact 10}.
\end{document}
</pre>

<p>
A <code>verbatim</code> environment will contain the code. To change the default
behavior and make Haskell code visible by default, pass the <code>-visible</code> flag when
invoking <code>haskintex</code>. Use then the <code>hidden</code> option to hide specific
calls to <code>writehaskell</code>.
</p>

<pre>
\documentclass{article}
\begin{document}
\begin{writehaskell}[hidden]
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n-1)
\end{writehaskell}
While 5 factorial is \evalhaskell{fact 5}, 10 factorial is
\evalhaskell{fact 10}.
\end{document}
</pre>

<h1>Flag reference</h1>

<p>
Below a list of the flags accepted by the program. Any argument starting with <code>-</code>
will be recognized as a flag, even if it is not defined (in which case, it will have no effect).
Anything else will be considered an input file. For instance, this is a valid invocation to
process the file <code>foo.tex</code> verbosely: <code>haskintex foo -verbose</code>.
</p>

<ul><li>
<code>help</code>: Show the version of the program and some information, like usage and
a description of the different flags.
</li>
<li><code>keep</code>: Do not remove the auxiliary module after the program ends.
The name of the auxiliary module is the name of the input file preceded by <code>Haskintex_</code>.
</li>
<li><code>lhs2tex</code>: By default, <i>haskintex</i> uses basic LaTeX <code>verb</code>
and <code>verbatim</code> declarations for Haskell code. When this flag is enabled, the output
will be formatted for <a href="http://www.andres-loeh.de/lhs2tex">lhs2TeX</a>.</li>
<li><code>manual</code>: This flag will make <i>haskintex</i> write <code>evalhaskell</code>
and <code>writehaskell</code> outputs unchanged. In other words, no <code>verb</code>,
<code>verbatim</code>, or <code>code</code> (in case the lhs2tex flag is enabled) declarations
will be used.</li>
<li><code>stdout</code>: Instead of writing the final output to a file, send it to the standard
output stream (usually, the screen), making possible to redirect the output to another application.</li>
<li><code>verbose</code>: While working, print information on the screen about the execution.</li>
<li><code>visible</code>: Make Haskell code in <code>writehaskell</code> environments visible by default.</li>
</ul>

<!-- <h1>Known issues</h1> -->

<h1>Code repository</h1>

<p>
The code of <i>haskintex</i> is hosted on <a href="https://github.com/Daniel-Diaz/haskintex">GitHub</a>.
For suggestions, bug reports, or any other concern, fill an issue at the
<a href="https://github.com/Daniel-Diaz/haskintex/issues">Issue Tracker</a>.
</p>
</body>
